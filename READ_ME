Little Smalltalk, Version 2
=======================================================================
General Overview

First, the obvious facts.  This is not Smalltalk-80, nor even Smalltalk-V.
This is the second version of the Little Smalltalk system, the first version
of which is described in the book published by Addison-Wesley*.

Version two is smaller and faster; does more in Smalltalk, not in C; and is
designed to be more portable to a wider variety of machines (we are working
on versions now for various PCs).  

My attitude towards the language has been rather cavalier; what I liked I 
kept and what I didn't like I tossed out. This is explained in more detail 
in my book and in the end of this note. As a consequence, individuals familiar 
with ST-80 or ST-V will be struck by how much they are missing, and I make 
no apologies for this.  On the other hand, you don't find ST-V posted to 
net.sources.  Among the features you won't find here are metaclasses, class 
methods, windows, graphics support, and more.

What you will find is a small language that does give you the flavor of
object oriented programming at very little cost.  We are working to improve
the system, and hope to distribute new versions as we develop them, 
as well as porting it to a wide range of machines.

 * If you find (and preferably, fix!) bugs let us know.
 * If you make nice additions let us know.
 * If you want to make complements let us know.
 * If you want to make complaints let us know.
 * If you want support you just might be out of luck.

This software is entirely public domain.  You are encouraged to give it
to as many friends as you may have.  As a courtesy, I would appreciate it
if you left my name on the code as the author, but I make no other claims
to it (I also, of course, disavow any liability for any bizarre things you
may choose to do with it).  Enjoy.


Building the System

There are three steps involving in building the system; making the parser
(the component used to generate the initial object image), making the
bytecode interpreter, and making the object image.

After you have unbundled all the files, to create the parser type

  make parse

The resulting program, called parse, is used to generate the object image
initially loaded into the bytecode interpreter.

Next, make the interpreter itself by typing

  make st

Note that the interpreter and the parser share some files. Finally, produce 
an initial object image.  The image created when you type

  make sunix

is the smallest and fastest.  It is a single process version of smalltalk.
A buggy multiprocess version can be created by typing ``make munix''*.

* Multi processing from munix is done entirely in Smalltalk.

  While this is a good idea from the point of view of keeping the bytecode
  interpreter small and giving one the greatest flexibility, there seems to
  be a dramatic performance penalty.  I'm considering the alternatives.

Of more interest, an image containing test cases (***currently only
the 8 queens***) can be generated by typing ``make stest''.
In the latter case, the command ``test all'', when given in response to the
prompt (see below), runs all the test cases.

Once you have created an object image, type 

  ./st

to run the system.

By default the image file ``imageFile'' is read.  You can optionally
use a different image file by giving the name on the command line following
the st command.


Getting Started

When you start version two Little Smalltalk under Unix, you will be given a 
prompt.

You can enter expressions in response to the prompt, and the system will 
evaluate them (although it will not print the result unless you request it).
For example:

  >  (4 + 5) print
  7

You can create a new global variable (a variable known every place, including
the command line) by simply inserting a command into the dictionary that
maintains the names of all global variables.  You use as key the name of
the new global variable (as a Symbol), and as value the initial value to 
be associated with the variable.

  >  globalNames at: #i put: 17
  >  i print
  17

Global variables cannot be modified by the assignment arrow.  In particular,
the following gives an error:

  >  i <- 16
  Compiler error: unknown variable i

Global variables can, however, be used in expressions:

  >  (i + 3) print
  20

The most common use for global variables is creating a new Class.  A Class
is simply a global variable, by convention (but only convention) being given
a name beginning with an uppercase letter.  For example:

  >  globalNames at: #Employee put: Class new

This creates a new class called Employee, an instance of class Class. 
Various messages, understood by instances of class Class, can be used to 
initialize various features of this new object. (This would be a good 
time to take a peek at the file ``basicclasses'', which contains a textual 
description of all the methods used in the standard classes.  Note 
carefully the methods used in class Class).

  >  globalNames superClass: Object
  >  globalNames name: #Employee
  >  globalNames variables: #(department salary)

The most important initializing message is addMethod, which 
drops you into an editor (currently only vi), in which you enter
the body of a method.  When you exit the editor the method is compiled,
and either entered into the method dictionary for the class (if there
are no errors) or a sequence of error messages are displayed on the output
device.

To save an object image, type the command

  smalltalk saveImage

You will be prompted for the name of the image file.


Changes from Little Smalltalk version one

The following changes have been made from version one to version two:

 * The user interface is slightly different.  This is most apparent in the way
   new classes are added (see above).
 * Much (very much) more of the system is now written in Smalltalk, rather
   than C.  This allows the user to see, and modify it if they wish.
   This also means that the virtual machine is now much smaller.
 * The pseudo variable selfProcess is no longer supported.
   The variables true, false and nil are now treated as global variables, not
   pseudo variables (see below).
 * There are plans for adding processes to version two, but they have not
   been formalized yet.
 * Global variables are now supported; in fact classes are now simply global
   variables, as are the variables true, false, smalltalk and nil.
   The global variable globalNames contains the dictionary of all currently
   known global variables and their values.
   (Pool variables are still not supported).
 * The internal bytecodes are slightly different.  In particular, the bytecode
   representing ``send to super'' has been eliminated, and a bytecode representing
   ``do a primitive'' has been added.
 * The Collection hierarchy has been rearranged.  The rational for this change
   is explained in more detail in another essay.
   (possibly not written yet).
 * Some methods, most notably the error message methods, have been moved out
   of class Object and into class Smalltalk.
 * The syntax for primitives is different; the keyword \fBprimitive\fP has been
   eliminated, and named primitives are now gone as well.
   Fewer actions are performed by primitives, having been
   replaced by Smalltalk methods.
 * Command line options, such as the fast load feature, have been eliminated.
   However, since version two reads in a binary object image, not a textual
   file, loading should be considerably faster.


Changes

I want to emphasize that this is not even a beta-test version (does that
make it an alpha or a gamma version?).  I will be making a number of
changes, hopefully just additions to the initial image, in the next
few months.  In addition, I hope to prepare versions for other machines,
notably the Macintosh and the IBM PC.  I am also encouraging others to
port the system to new machines.  If you have done so, please let me
know.
